//  Star Wars TSG
//  Darel Rex Finley, 2006-2011



#include                     "nil.h"
#include                    "bool.h"
#include             "definitions.h"
#include "DistributorSearchlights.h"
#include             "Distributor.h"
#include                  "FilmCo.h"
#include                   "Intro.h"
#include               "TitleFont.h"
#include           "SequenceTimes.h"
#include       "Shared Structures.h"
#include           "cbf functions.h"
#include  "image buffer functions.h"
#include      "geometry functions.h"
#include        "string functions.h"
#include       "numeric functions.h"
#include                    "math.h"
#include                  "stdlib.h"

#include           "TitleAndCrawl.h"



//=====CRAWL VARS START HERE



//  Indicates that the starfield should be generated by code, instead of loaded from a file.
bool  AutoStarfield=YES ;



//  Speed at which the Crawl moves.  Calculated only once, on app launch.
double  CrawlSpeed ;



//  Array of information about which characters in the Crawl are possibly related to a given row of pixels (to help
//  speed up rendering).  CrawlRowHi gives special, extra resolution to the topmost pixel rows -- it prevents the
//  crawl from flickerly badly in the far distance.
CrawlRow_  CrawlRow  [IMAGE_HEI_MAX][OVERSCAN_HI            ] ;
CrawlRow_  CrawlRowHi[CRAWL_HI_ROWS][OVERSCAN_HI*OVERSCAN_HI] ;
int4       CrawlRowSubPixels=0 ;



//  Globals used during rendering of Crawl image.  (Populated primarily
//  by prepareToDrawCrawlImage; used primarily by drawCrawlPixel.)
int4         CrawlText[MAX_CHARS_CRAWL+1] ;
CrawlChar_   CrawlChar[MAX_CHARS_CRAWL  ] ;
double       CrawlOpacity=1. ;
int4         CrawlChars      ;



//  Crawl cbf (font).
BYTE  *CbfCrawl=nil ;



double  CrawlBottomEdge ;



//=====TITLE VARS START HERE



//  Globals used during rendering of Title image.  (Populated primarily by prepareToDrawTitleImage; used
//  primarily by drawCrawlPixel -- there is no such thing as drawTitlePixel.)
double  TitleDist=1., TitleOpacity=0. ;



int4  RasterSubPixels_Title ;



//  Populated by processTitleFont().  Information about the glyphs of the Title font, for use in speeding up rendering.
TitleGlyph_  *TitleGlyph=NULL ;
int4          TitleGlyphs     ;



//  Globals used during rendering of Title image.  (Populated primarily
//  by prepareToDrawTitleImage; used primarily by drawCrawlPixel.)
double      TitleMovieScreenWidth, TitleGlyphToMovieScreenRatio ;
int4        TitleText[MAX_CHARS_TITLE+1] ;
TitleChar_  TitleChar[MAX_CHARS_TITLE  ] ;
int4        TitleChars ;



//=====STARFIELD VARS START HERE



//  Star locations.
Star_     Star   [STARS        ] ;
SubStar_  SubStar[IMAGE_HEI_MAX] ;   //  (helps speed up render by associating certain stars with each pixel row)

bool      StarsImageReady ;



//  Returns the total time from the crawl’s first appearance to when the crawl first starts fading away.

double calcCrawlHeightTime(double crawlToAllTextVisible) {

  double  time=0. ;
  int     i ;

  for (i=CRAWL_AND_TITLE_PULL_BACK; i<CRAWL_TO_ALL_TEXT_VISIBLE; i++) time+=SequenceTimes[i*2];

  return time+crawlToAllTextVisible; }



//  Finds the bottom edge of the Crawl (in its own, non-perspective coordinate system -- see the file
//  “Coordinate Systems”).

double calcCrawlBottom() {
  if (CrawlChars) return CrawlChar[CrawlChars-1].rect.B-CRAWL_LINE_SEP*.5;
  else            return                               -CRAWL_LINE_SEP*.5; }



//  Forces re-creation of CrawlRow arrays.  (See CrawlRow definition above.)

void forceCrawlRowArrayCreation() {
  CrawlRowSubPixels=0; }



//  Forces the area of the image in which the Crawl resides to be re-rendered.
//
//  Call this function immediately before and again immediately after the text moves or otherwise changes.
//
//  Note:  The controller never calls this function with render threads running.

void forceRasterCrawl(bool hi, bool lo) {

  double  lt, rt, t, lb, rb, b ;

  //  Exit if there is no text to render.
  if (!CrawlChars) return;

  //  Determine the area that needs to be rendered.
  lt=-1.; lb=-1.; t=0.;  b=CrawlChar[CrawlChars-1].rect.B-1./FramesPerSecond*CrawlSpeed;
  if (b<CrawlBottomEdge) b=CrawlBottomEdge ;
  crawlFwdPerspective(&lt,&t,CrawlBottomEdge); rt=-lt;
  crawlFwdPerspective(&lb,&b,CrawlBottomEdge); rb=-lb;

  //  Force the needed area to be rendered.
  forceRasterParallelagram(lo,hi,
  (int4) screenToPixelX(lt)-3,
  (int4) screenToPixelX(rt)+4,
  (int4) screenToPixelY( t)-3,
  (int4) screenToPixelX(lb)-3,
  (int4) screenToPixelX(rb)+4,
  (int4) screenToPixelY( b)+4); }



//  Basic perspective -- converts a point in the Crawl text coordinate system to a movie-screen point such that the
//  text will be displayed in the correct off-to-the-distance perspective.  (See the file “Coordinate Systems”.)

void crawlFwdPerspective(double *x, double *y, double crawlBottom) {

  double  dist=1.+CRAWL_PERSP_STRENGTH*((*y)-crawlBottom) ;

  *x/=dist/CRAWL_X_STRETCH;
  *y =CRAWL_VANISH_Y+(-.5-CRAWL_VANISH_Y)/dist; }



//  This function is the reverse of crawlFwdPerspective.

void crawlRevPerspective(double *x, double *y, double crawlBottom) {

  double  dist ;

  *y=((-.5-CRAWL_VANISH_Y)/((*y)-CRAWL_VANISH_Y)-1.)/CRAWL_PERSP_STRENGTH+crawlBottom;
  dist=1.+CRAWL_PERSP_STRENGTH*((*y)-crawlBottom);
  *x*=dist/CRAWL_X_STRETCH; }



//  Perform the necessary preparations for rendering the Crawl image.
//
//  Returns an error string, or nil (not an empty string) if there is no error.

BYTE *prepareToDrawCrawlImage(BYTE **rgb, int4 rowBytes) {

  bool    done=NO, lastRowWrapped=NO, rowAllCaps=YES ;
  int4    i, j, k, c, newI, rowStart, afterSpace     ;
  double  charWid ;

  //  Error check.
  if (!CbfCrawl) return "prepareToDrawCrawlImage called with nil CbfCrawl.";

  straightQuotesToDirectional(&CrawlText[0]);
  fixReturnAndNewlineChars   (&CrawlText[0]);

  forceCrawlRowArrayCreation();

  //  Store the passed parameters in globals, for use during image drawing.
  PreviewRgb     =rgb     ;
  PreviewRowBytes=rowBytes;

  //  Parse the crawl text into a set of character positions in a space that horizontally spans -1 (left)
  //  to +1 (right), and vertically spans from 0 (top) to a text-content-dependent, negative value (bottom).
  //  (See the file “Coordinate Systems”.)
  i=0; rowStart=0;
  while (!done) {
    c=CrawlText[i];
    if (c) {
      //  Create a new CrawlChar entry.
      CrawlChar[i].uni=c; if (isLowerCase(c)) rowAllCaps=NO;
      charWid=(double) cbfWidth(CbfCrawl,&c)*CRAWL_LINE_HEI/(double) cbfHeight(CbfCrawl);
      if (i==rowStart) {
        if (!i) {
          CrawlChar[0].rect.T=0.; CrawlChar[0].rect.B=-CRAWL_LINE_HEI; }
        else {
          CrawlChar[i].rect.T=CrawlChar[i-1].rect.B-CRAWL_LINE_SEP;
          CrawlChar[i].rect.B=CrawlChar[i  ].rect.T-CRAWL_LINE_HEI; }
        CrawlChar  [i].rect.L=-1.;
        CrawlChar  [i].rect.R=-1.+charWid; }
      else {
        CrawlChar  [i].rect.T=CrawlChar[i-1].rect.T               ;
        CrawlChar  [i].rect.B=CrawlChar[i-1].rect.B               ;
        CrawlChar  [i].rect.L=CrawlChar[i-1].rect.R+CRAWL_CHAR_SEP; if (charWid==0.) CrawlChar[i].rect.L=CrawlChar[i-1].rect.R;
        CrawlChar  [i].rect.R=CrawlChar[i  ].rect.L+       charWid; }
      //  Discover if text-wrapping is needed.
      if (CrawlChar[i].rect.R>1. && c!=' ' && c!=RETURN_CHAR) {   //  (wrap)
        lastRowWrapped=YES;
        //  (backtrack characters out of the current row)
        afterSpace=i; while (afterSpace>rowStart && CrawlText[afterSpace-1]!=' ') afterSpace--;
        if (afterSpace>rowStart) i=afterSpace;
        rowStart=i--; }}
    //  Decide what to do with a row that ends without wrapping.
    if (!c || c==RETURN_CHAR) {
      if (i>rowStart && !lastRowWrapped && CrawlChar[rowStart].uni!=' ') {   //  (center the row)
        for (j=rowStart; j<=i; j++) {
          if (CrawlText[j]) {
            CrawlChar[j].rect.L+=(1.-CrawlChar[i-1].rect.R)*.5;
            CrawlChar[j].rect.R+=(1.-CrawlChar[i-1].rect.R)*.5;
            if (rowAllCaps) {   //  (also vertically stretch the row)
              CrawlChar[j].rect.B-=CRAWL_LINE_HEI; }}}}
      rowStart=i+1; rowAllCaps=YES; lastRowWrapped=NO; }
    //  Continue loop until done with all text.
    if (c) i++;
    else   done=YES; }
  CrawlChars=i;

  //  Right-and-left justify the text.
  i=0;
  while (i<CrawlChars && CrawlChar[i].rect.T>CrawlChar[CrawlChars-1].rect.T) {
    newI=i; while (CrawlChar[newI].rect.T==CrawlChar[i].rect.T) newI++;
    if (CrawlText[newI-1]!= RETURN_CHAR
    &&  CrawlText[newI-1]!=NEWLINE_CHAR) {
      j=newI; while (CrawlText[j-1]==' ' || CrawlText[j-1]==RETURN_CHAR || CrawlText[j-1]==NEWLINE_CHAR) j--;
      for (k=i+1; k<j; k++) {
        CrawlChar[k].rect.L+=(double) (k-i)*(1.-CrawlChar[j-1].rect.R)/(double) (j-1-i);
        CrawlChar[k].rect.R+=(double) (k-i)*(1.-CrawlChar[j-1].rect.R)/(double) (j-1-i); }}
    i=newI; }
  //  (strip out invisible characters for faster image rendering)
  j=0;
  for (i=0; i<CrawlChars; i++) {
    CrawlChar[j]=CrawlChar[i]; if (CrawlChar[j].uni!=' ' && CrawlChar[j].rect.R-CrawlChar[j].rect.L>0.) j++; }
  CrawlChars=j;

  //  Success.
  return nil; }



//  Populates the CrawlRow array -- see CrawlRow definition above.

void buildCrawlRowArray() {

  int4    i, j, jj, subPixels2=RasterSubPixels*RasterSubPixels ;
  double  x, y ;

  CrawlRowSubPixels=RasterSubPixels;
  for  (j=ImageHeiLetterBox; j<ImageHeiLetterBox+ImageHeiUsed; j++) {
    if (j-ImageHeiLetterBox>=CRAWL_HI_ROWS || CrawlRowSubPixels<OVERSCAN_HI) {
      for (jj=0; jj<RasterSubPixels; jj++) {
        CrawlRow[j][jj].start=0;
        CrawlRow[j][jj].end  =0;
        if (CrawlChars) {
          x=0.; y=pixelToScreenY((double) j+((double) jj+.5)/(double) CrawlRowSubPixels); crawlRevPerspective(&x,&y,CrawlBottomEdge);
          if (y<=0. && y>=CrawlChar[CrawlChars-1].rect.B) {
            for (i=0; i<CrawlChars; i++) {
              if (y< CrawlChar[i].rect.T
              &&  y>=CrawlChar[i].rect.B) {
                CrawlRow[j][jj].start=i  ; break; }}
            for (i=CrawlChars-1; i>=0; i--) {
              if (y< CrawlChar[i].rect.T
              &&  y>=CrawlChar[i].rect.B) {
                CrawlRow[j][jj].end  =i+1; break; }}}}}}
    else {   //  (special processing for topmost rows, to prevent bad flickering/pulsing of most-distant crawl text)
      for (jj=0; jj<subPixels2; jj++) {
        CrawlRowHi[j-ImageHeiLetterBox][jj].start=0;
        CrawlRowHi[j-ImageHeiLetterBox][jj].end  =0;
        if (CrawlChars) {
          x=0.; y=pixelToScreenY((double) j+((double) jj+.5)/(double) subPixels2); crawlRevPerspective(&x,&y,CrawlBottomEdge);
          if (y<=0. && y>=CrawlChar[CrawlChars-1].rect.B) {
            for (i=0; i<CrawlChars; i++) {
              if (y< CrawlChar[i].rect.T
              &&  y>=CrawlChar[i].rect.B) {
                CrawlRowHi[j-ImageHeiLetterBox][jj].start=i  ; break; }}
            for (i=CrawlChars-1; i>=0; i--) {
              if (y< CrawlChar[i].rect.T
              &&  y>=CrawlChar[i].rect.B) {
                CrawlRowHi[j-ImageHeiLetterBox][jj].end  =i+1; break; }}}}}}}}



//  Renders one pixel of the Crawl (and/or Title) image.

void drawCrawlPixel(BYTE *r, BYTE *g, BYTE *b, int4 pixelX, int4 pixelY,
int4 *cbfChar, BYTE *cbfFill, short *cbfX, short *cbfY, bool *cbfRaw, BYTE **cbfData,
BYTE *starImage, bool drawStars, bool *nodeRowsReady, int4 *nodes, double *nodeX, int4 *polyTag, int4 *nodeNext,
bool *inPoly, bool *inInnerPoly,
BYTE *starsR, BYTE *starsG, BYTE *starsB, int4 starsWid, int4 starsHei, int4 starsRowBytes) {

  double  subPixels2, subPixelPart, subPixelPart2, subPixelPart_Title, *glyph, titleBlackCore[TITLE_GLYPH_MAX_BYTES] ;
  double  starFracR, starFracG, starFracB, starAdd, textFrac, screenX, screenY, x, y, yellowFrac ;
  int4    i, c, rowStart, rowEnd, uni, uniBefore, uniAfter, starfieldPlaneIndex ;
  double  titleFrac, titleYellowFrac, starScreen, textLev ;
  int4    ii, jj, crawlPixelX, crawlPixelY, *ptrToLong    ;
  BYTE    glyphLevel ;

  subPixels2=RasterSubPixels; if (pixelY-ImageHeiLetterBox<CRAWL_HI_ROWS) subPixels2*=RasterSubPixels;
  if (subPixels2>OVERSCAN_MAX) subPixels2=OVERSCAN_MAX;
  subPixelPart      =1./((double) RasterSubPixels      *(double) RasterSubPixels      );
  subPixelPart2     =1./((double)       subPixels2     *(double)       subPixels2     );
  subPixelPart_Title=1./((double) RasterSubPixels_Title*(double) RasterSubPixels_Title);

  //  Letterbox to black, if appropriate for this pixel.
  if (pixelY< ImageHeiLetterBox
  ||  pixelY>=ImageHeiLetterBox+ImageHeiUsed) {
    *r=(BYTE) 0;
    *g=(BYTE) 0;
    *b=(BYTE) 0; }
  else {

    //  For Title:  Build the whole-row node array(s), if they need to be built.
    //  See this webpage for an explanation of whole-row node rendering:  http://alienryderflex.com/polygon_fill
    if (!(*nodeRowsReady) && TitleOpacity>0.) {
      *nodeRowsReady=YES;
      for (jj=0L; jj<(int4) RasterSubPixels_Title; jj++) {   //  (vertical subpixel loop)
        nodes[jj]=0; screenY=pixelToScreenY((double) pixelY+((double) jj+.5)/(double) RasterSubPixels_Title);
        for (i=0; i<TitleChars; i++) {
          if (screenY*TitleDist>=TitleChar[i].Bextra
          &&  screenY*TitleDist<=TitleChar[i].Textra) {
            uni=TitleChar[i].uni; glyph=&TitleFont[TitleGlyph[uni].start];
            if (i             ) uniBefore=TitleChar[i-1].uni;
            else                uniBefore=0;
            if (i<TitleChars-1) uniAfter =TitleChar[i+1].uni;
            else                uniAfter =0;
            //  Outer edge of a yellow character.
            addNodesFromSplineArcPoly_Title(glyph,screenY*TitleDist,jj,TitleChar[i],
            TitleGlyph[TitleChar[i].uni].width,0L,nodes,nodeX,polyTag,
            TitleGlyph[uni].ribbonTLi,TitleGlyph[uni].ribbonTRi,
            TitleGlyph[uni].ribbonBLi,TitleGlyph[uni].ribbonBRi,
            TitleChar[i].rowL,TitleChar[i].rowT,TitleChar[i].rowR,TitleChar[i].rowB,uniBefore,uniAfter);
            //  Edge of a black character core.
            constructTitleGlyphBlackCore(glyph,&titleBlackCore[0]);
            addNodesFromSplineArcPoly_Title(&titleBlackCore[0],screenY*TitleDist,jj,TitleChar[i],
            TitleGlyph[TitleChar[i].uni].width,1L,nodes,nodeX,polyTag,
            TitleGlyph[uni].ribbonTLi,TitleGlyph[uni].ribbonTRi,
            TitleGlyph[uni].ribbonBLi,TitleGlyph[uni].ribbonBRi,
            TitleChar[i].rowL,TitleChar[i].rowT,TitleChar[i].rowR,TitleChar[i].rowB,uniBefore,uniAfter); }}
        sortNodeRow(jj,nodes,nodeX,polyTag); nodeNext[jj]=0; inPoly[jj]=NO; inInnerPoly[jj]=NO; }}

    //  Build the CrawlRow arrays, if they need to be built.
    if (CrawlRowSubPixels!=RasterSubPixels) buildCrawlRowArray();

    //  Prepare to construct the image pixel.
    textFrac =0.;
    starFracR=0.;
    starFracG=0.;
    starFracB=0.;
    titleFrac=0.; titleYellowFrac=0.;

    //  Crawl text.
    if (CrawlChars && CrawlOpacity>0.) {
      for   (jj=0L; jj<(int4) subPixels2; jj++) {   //    vertical subpixel loop
        screenY  =pixelToScreenY((double) pixelY+((double) jj+.5)/(double) subPixels2);
        if (subPixels2<=OVERSCAN_HI) {
          rowStart=CrawlRow  [pixelY                  ][jj].start;
          rowEnd  =CrawlRow  [pixelY                  ][jj].end  ; }
        else {
          rowStart=CrawlRowHi[pixelY-ImageHeiLetterBox][jj].start;
          rowEnd  =CrawlRowHi[pixelY-ImageHeiLetterBox][jj].end  ; }
        for (ii=0L; ii<(int4) subPixels2; ii++) {   //  horizontal subpixel loop
          screenX=pixelToScreenX((double) pixelX+((double) ii+.5)/(double) subPixels2);
          x=screenX;
          y=screenY; crawlRevPerspective(&x,&y,CrawlBottomEdge);
          if (x>=-1. && x<=1. && y<=0. && y>=CrawlChar[CrawlChars-1].rect.B) {
            for (i=rowStart; i<rowEnd; i++) {
              if     (inDoubleRect(CrawlChar[i].rect,x,y)) {
                c          =(int4) CrawlChar[i].uni;
                crawlPixelX=(int4) ((double) cbfWidth (CbfCrawl,&c)*(x-CrawlChar[i].rect.L  )/(CrawlChar[i].rect.R-CrawlChar[i].rect.L));
                crawlPixelY=(int4) ((double) cbfHeight(CbfCrawl   )*(  CrawlChar[i].rect.T-y)/(CrawlChar[i].rect.T-CrawlChar[i].rect.B));
                //  Repopulate the font decompression variables, if they’re not in a state to use as-is.
                if ((int4) cbfY[jj]!=crawlPixelY || cbfChar[jj]!=c || (int4) cbfX[jj]>crawlPixelX) {
                  ptrToLong=(int4 *) &CbfCrawl[8L+4L*(int4) c];
                  cbfChar[jj]=c; cbfFill[jj]=(BYTE) 0; cbfX[jj]=0; cbfY[jj]=(short) crawlPixelY; cbfRaw[jj]=NO;
                  ptrToLong=(int4 *) (CbfCrawl+(*ptrToLong)+4L+4L*cbfY[jj]);
                  cbfData[jj]=CbfCrawl+(*ptrToLong); }
                //  First, find the region (“fill” or “raw”) that includes the desired pixel.
                while (cbfX[jj]+ (short) cbfData[jj][0]<=crawlPixelX) {
                  cbfX     [jj]+=(short) cbfData[jj][0];
                  if (cbfRaw[jj]) {   //   “raw” mode
                    if (cbfData[jj][0]) {
                      cbfData[jj]+=cbfData[jj][0];
                      if (cbfData[jj][0]<(BYTE) 128) cbfFill[jj]=(BYTE)   0;
                      else                           cbfFill[jj]=(BYTE) 255; }
                    else {
                      cbfFill[jj]=(BYTE) 255-cbfFill[jj]; }
                    cbfData[jj]++; cbfRaw[jj]=NO; }
                  else {              //  “fill” mode
                    if (cbfData[jj][0]==(BYTE) 255) {
                      cbfData[jj]++; }
                    else {
                      cbfData[jj]++; cbfRaw[jj]=YES; }}}
                //  Then determine the greyscale level (0-255) of that pixel.
                if (cbfRaw[jj]) {     //   “raw” mode
                  glyphLevel=cbfData[jj][1+crawlPixelX-cbfX[jj]]; }
                else {                //  “fill” mode
                  glyphLevel=cbfFill[jj]; }
                //  Use the pixel value that was found.
                textLev    =(double) glyphLevel;
                textFrac  +=textLev*subPixelPart2;
                break; }}}}}
      textFrac/=255.; }

    //  Title.
    if (TitleOpacity>0.) {
      for   (jj=0L; jj<(int4) RasterSubPixels_Title; jj++) {   //    vertical subpixel loop
        for (ii=0L; ii<(int4) RasterSubPixels_Title; ii++) {   //  horizontal subpixel loop
          screenX=pixelToScreenX((double) pixelX+((double) ii+.5)/(double) RasterSubPixels_Title);
          while (nodeNext[jj]<nodes[jj] && nodeX[jj*NODE_ROW_MAX+nodeNext[jj]]<screenX*TitleDist) {
            if (polyTag[jj*NODE_ROW_MAX+nodeNext[jj]]) inInnerPoly[jj]=!inInnerPoly[jj];
            else                                            inPoly[jj]=!     inPoly[jj];
            nodeNext[jj]++; }
          if (inPoly[jj]) {
            titleFrac                            +=subPixelPart_Title;
            if (!inInnerPoly[jj]) titleYellowFrac+=subPixelPart_Title; }}}}

    //  Make the Title fade away.
    titleFrac      *=TitleOpacity;
    titleYellowFrac*=TitleOpacity;

    //  Make the Crawl fade away.
    textFrac       *=CrawlOpacity;

    //  Star field.
    if (drawStars) {
      if (AutoStarfield) {
        starScreen=1.-titleFrac-textFrac;   //  (assumes Title and Crawl never overlap, i.e. never share pixels)
        if (starScreen>0.) {
          if (StarsImageReady) {
            starFracR=(double) starImage[ImageWid*pixelY+pixelX]/255.;
            starFracG=starFracR;
            starFracB=starFracR; }
          else {
            for   (jj=0L; jj<(int4) RasterSubPixels; jj++) {   //    vertical subpixel loop
              screenY  =pixelToScreenY((double) pixelY+((double) jj+.5)/(double) RasterSubPixels);
              for (ii=0L; ii<(int4) RasterSubPixels; ii++) {   //  horizontal subpixel loop
                screenX=pixelToScreenX((double) pixelX+((double) ii+.5)/(double) RasterSubPixels);
                starAdd   =starLev(screenX,screenY,pixelY)*subPixelPart;
                starFracR+=starAdd;
                starFracG+=starAdd;
                starFracB+=starAdd; }}}
          starFracR*=starScreen;
          starFracG*=starScreen;
          starFracB*=starScreen; }}
      else {   //  (use custom starfield image from file)
        starScreen=1.-titleFrac-textFrac;   //  (assumes Title and Crawl never overlap, i.e. never share pixels)
        if (starScreen>0.) {
          starfieldPlaneIndex=starsRowBytes*(int4) ((double) (pixelY-ImageHeiLetterBox)/(double) ImageHeiUsed*(double) starsHei)
          +                                 (int4) ((double)  pixelX                   /(double) ImageWid    *(double) starsWid);
          starScreen/=255.;
          starFracR=(double) starsR[starfieldPlaneIndex]*starScreen;
          starFracG=(double) starsG[starfieldPlaneIndex]*starScreen;
          starFracB=(double) starsB[starfieldPlaneIndex]*starScreen; }}}

    //  Prevent pixel overload.
    if (starFracR>1.) starFracR=1.;
    if (starFracG>1.) starFracG=1.;
    if (starFracB>1.) starFracB=1.;

    //  Put the calculated pixel value into the displayable bitmap.
    yellowFrac=textFrac+titleYellowFrac;
    *r=(BYTE) (starFracR*255.+yellowFrac*(double) CRAWL_COLOR_R);
    *g=(BYTE) (starFracG*255.+yellowFrac*(double) CRAWL_COLOR_G);
    *b=(BYTE) (starFracB*255.+yellowFrac*(double) CRAWL_COLOR_B); }}



//=====TITLE FUNCTIONS STARTS HERE



//  This function is closely related to addNodesFromSplineArcPoly_FilmCo (see comments at that
//  function), but it is simplified for use only by drawCrawlPixel() to generate the Title logo.
//
//  See the file “Polygon Constants” for a detailed description of how the polygon tags work.
//
//  This function recognizes only ARC_AUTO, NEW_LOOP, NO_CORE, and END_POLY tags in the polygon data.
//
//  Note:  If polyCount is non-zero, a NO_CORE tag will terminate processing of the polygon --
//         otherwise NO_CORE will just be skipped over.
//
//  See this webpage for an explanation of whole-row node rendering:  http://alienryderflex.com/polygon_fill
//
//  See this webpage for an explanation of the point-in-spline-polygon technique:  http://alienryderflex.com/polyspline
//
//  See the files “ARC Points” and “Polygon Constants” for detail about how ARC and ARC_AUTO work.

void addNodesFromSplineArcPoly_Title(double *poly, double y, int4 subPixelRow, TitleChar_ charLoc,
double glyphWid, int4 polyCount, int4 *nodes, double *nodeX, int4 *polyTag,
int4 ribbonTL, int4 ribbonTR, int4 ribbonBL, int4 ribbonBR, bool rowL, bool rowT, bool rowR, bool rowB,
int4 uniBefore, int4 uniAfter) {

  double  arcAx, arcAy, arcBx, arcBy, arcCx, arcCy, arcDx, arcDy, abExtend, dcExtend, dX, dY, distAB ;
  double  arcSplineBx, arcSplineBy, arcSplineCx, arcSplineCy, arcHardX, arcHardY, sectX ;
  double  a, b, sX, sY, eX, eY, rotCx, rotCy, rotDx, rotDy, theCos, theSin, preCalc     ;
  int4    i=0, j, k, start=0 ;

  y+=.000001;   //  Prevent the need for special tests when f (a variable in functions called by this one) is exactly 0 or 1.

  while (poly[i]!=END_POLY) {
    if  (poly[i]== NO_CORE) {
      i++; start++; if (polyCount) return; }
    j=i+2;  if (poly[i]==SPLINE) j++;
    if (poly[j]==END_POLY || poly[j]==NEW_LOOP) j=start;

    if (poly[j]==ARC_AUTO) {       //  ** Arc Auto **
      //  Get the two line segments that will be connected by an arc.  Order:  A, B, arc, C, D
      arcAx=poly[i-2]; arcAy=poly[i-1];
      arcBx=poly[i  ]; arcBy=poly[i+1]; j++ ; if (poly[j]==END_POLY || poly[j]==NEW_LOOP) j=start;
      arcCx=poly[j  ]; arcCy=poly[j+1]; j+=2; if (poly[j]==END_POLY || poly[j]==NEW_LOOP) j=start;
      arcDx=poly[j  ]; arcDy=poly[j+1];
      //  Discover the length of line segment AB.
      dX=arcBx-arcAx; dY=arcBy-arcAy; distAB=sqrt(dX*dX+dY*dY);
      //  Translate the line segments so that point B is at the origin.
      rotCx=arcCx-arcBx; rotCy=arcCy-arcBy;
      rotDx=arcDx-arcBx; rotDy=arcDy-arcBy;
      //  Rotate the line segments so that point A is on the positive, X axis.
      theCos=(arcAx-arcBx)/distAB;
      theSin=(arcAy-arcBy)/distAB;
      rotatePointAroundOrigin(&rotCx,&rotCy,theCos,-theSin);
      rotatePointAroundOrigin(&rotDx,&rotDy,theCos,-theSin);
      //  Discover the extenders.
      dcExtend=rotCy/(rotDy-rotCy); sectX=rotCx+(rotCx-rotDx)*dcExtend;
      abExtend=-sectX/distAB;
      //  Discover the two spline corners created by the extenders.
      arcSplineBx=arcBx+(arcBx-arcAx)*abExtend*ARC_FRAC;
      arcSplineBy=arcBy+(arcBy-arcAy)*abExtend*ARC_FRAC;
      arcSplineCx=arcCx+(arcCx-arcDx)*dcExtend*ARC_FRAC;
      arcSplineCy=arcCy+(arcCy-arcDy)*dcExtend*ARC_FRAC;
      //  Discover the new, hard corner inbetween the two spline corners.
      arcHardX=(arcSplineBx+arcSplineCx)*.5;
      arcHardY=(arcSplineBy+arcSplineCy)*.5;
      //  Convert the spline’s glyph coordinates to movie-screen coordinates -- see the file “Coordinate Systems”.
      preCalc=(charLoc.rect.R-charLoc.rect.L)/glyphWid;
      arcBx      *=preCalc; arcBx      +=charLoc.rect.L;
      arcSplineBx*=preCalc; arcSplineBx+=charLoc.rect.L;
      arcHardX   *=preCalc; arcHardX   +=charLoc.rect.L;
      arcSplineCx*=preCalc; arcSplineCx+=charLoc.rect.L;
      arcCx      *=preCalc; arcCx      +=charLoc.rect.L; preCalc=(charLoc.rect.T-charLoc.rect.B)/TITLE_GLYPH_RANGE;
      arcBy      *=preCalc; arcBy      +=charLoc.rect.B;
      arcSplineBy*=preCalc; arcSplineBy+=charLoc.rect.B;
      arcHardY   *=preCalc; arcHardY   +=charLoc.rect.B;
      arcSplineCy*=preCalc; arcSplineCy+=charLoc.rect.B;
      arcCy      *=preCalc; arcCy      +=charLoc.rect.B;
      //  Process the two spline curves that simulate an arc.
      handleSplineCurveForNodesRow_Title(
      y,arcBx   ,arcBy   ,arcSplineBx,arcSplineBy,arcHardX,arcHardY,subPixelRow,polyCount,nodes,nodeX,polyTag);
      handleSplineCurveForNodesRow_Title(
      y,arcHardX,arcHardY,arcSplineCx,arcSplineCy,arcCx   ,arcCy   ,subPixelRow,polyCount,nodes,nodeX,polyTag); }

    else if (poly[i]!=SPLINE && poly[j]!=SPLINE) {   //  ** Line Segment **
      sX=poly[i]; sY=poly[i+1];
      eX=poly[j]; eY=poly[j+1];
      //  Decide whether this line segment should be processed or ignored.  (Ignoring is
      //  used to make the character hook up with an adjacent character, ribbon-style.)
      if ((i!=ribbonTL || rowL || TitleGlyph[uniBefore].ribbonTRi<0)
      &&  (i!=ribbonBL || rowL || TitleGlyph[uniBefore].ribbonBRi<0)
      &&  (i!=ribbonTR || rowR || TitleGlyph[uniAfter ].ribbonTLi<0)
      &&  (i!=ribbonBR || rowR || TitleGlyph[uniAfter ].ribbonBLi<0)) {
        //  Convert the spline’s glyph coordinates to movie-screen coordinates -- see the file “Coordinate Systems”.
        preCalc=(charLoc.rect.R-charLoc.rect.L)/glyphWid;
        sX*=preCalc; sX+=charLoc.rect.L;
        eX*=preCalc; eX+=charLoc.rect.L; preCalc=(charLoc.rect.T-charLoc.rect.B)/TITLE_GLYPH_RANGE;
        sY*=preCalc; sY+=charLoc.rect.B;
        eY*=preCalc; eY+=charLoc.rect.B;
        //  Create leading/trailing ribbons.
        if (rowL && (rowB && !rowT && i==ribbonTL || rowT && i==ribbonBL)) {
          sX=-TitleMovieScreenWidth*.5; if (polyCount) sX+=TITLE_CORE_INSET*TitleGlyphToMovieScreenRatio;
          eX=sX; }
        if (rowR && (rowB && !rowT && i==ribbonTR || rowT && i==ribbonBR)) {
          sX= TitleMovieScreenWidth*.5; if (polyCount) sX-=TITLE_CORE_INSET*TitleGlyphToMovieScreenRatio;
          eX=sX; }
        //  Process the line segment.
        handleLineSegmentForNodesRow(y,sX,sY,eX,eY,subPixelRow,polyCount,nodes,nodeX,polyTag); }}

    else if (poly[j]==SPLINE) {   //  ** Spline Curve **
      a=poly[j+1]; b=poly[j+2]; k=j+3; if (poly[k]==END_POLY || poly[k]==NEW_LOOP) k=start;
      if  (poly[i]!=SPLINE) {
        sX=poly[i]; sY=poly[i+1]; }
      else {   //  interpolate a hard corner
        sX=(poly[i+1]+poly[j+1])/2.; sY=(poly[i+2]+poly[j+2])/2.; }
      if  (poly[k]!=SPLINE) {
        eX=poly[k]; eY=poly[k+1]; }
      else {   //  interpolate a hard corner
        eX=(poly[j+1]+poly[k+1])/2.; eY=(poly[j+2]+poly[k+2])/2.; }
      //  Convert the spline’s glyph coordinates to movie-screen coordinates -- see the file “Coordinate Systems”.
      preCalc=(charLoc.rect.R-charLoc.rect.L)/glyphWid;
      sX*=preCalc; sX+=charLoc.rect.L;
      a *=preCalc; a +=charLoc.rect.L;
      eX*=preCalc; eX+=charLoc.rect.L; preCalc=(charLoc.rect.T-charLoc.rect.B)/TITLE_GLYPH_RANGE;
      sY*=preCalc; sY+=charLoc.rect.B;
      b *=preCalc; b +=charLoc.rect.B;
      eY*=preCalc; eY+=charLoc.rect.B;
      //  Process the spline curve.
      handleSplineCurveForNodesRow_Title(y,sX,sY,a,b,eX,eY,subPixelRow,polyCount,nodes,nodeX,polyTag); }

    //  Advance through the polygon data.  (See the file “Spline Corner Logic”.)
    if       (poly[i]==SPLINE  ) i++;
    i+=2; if (poly[i]==ARC_AUTO) i++;
    if       (poly[i]==NEW_LOOP) {
      i++; start=i; }}}



//  Used by the function titleKern when determining how close to space two characters of the Title.
//
//  This function is closely related to addNodesFromSplineArcPoly_Title and others (see comments of
//  addNodesFromSplineArcPoly_Title).
//
//  Returns YES if all parts of polyA are at least TITLE_CHAR_SEP distance from all parts of polyB.
//
//  Important:  For use only with the Title font.
//
//  Note:  When calling this function, you should pass glyph pointers in “poly” and “poly2”, and
//         should pass the non-kerned, X-offset position of poly2 in “poly2pos” -- but you do not
//         need pass any real data in the other input parameters; just pass in dummy values, which
//         will be ignored.  (Those parameters are used only when this function calls itself.)
//
//  See this webpage for an explanation of the point-in-spline-polygon technique:
//  http://alienryderflex.com/polyspline
//
//  See the file “Polygon Constants” for a detailed description of how the polygon tags work, and
//  see the files “ARC Points” and “Polygon Constants” for detail about how ARC and ARC_AUTO work.

bool titleKerningDistanceTest(double kernDist, double kernOvalness,
double *poly, double *poly2, double poly2pos,
bool isSpline, double testSx, double testSy, double testSplineX, double testSplineY, double testEx, double testEy) {

  double  abExtend, dcExtend, dX, dY, distAB, theCos, theSin, rotCx, rotCy, rotDx, rotDy, sectX ;
  double  a, b, sX, sY, eX, eY, arcAx, arcAy, arcBx, arcBy, arcCx, arcCy, arcDx, arcDy ;
  double  arcSplineBx, arcSplineBy, arcSplineCx, arcSplineCy, arcHardX, arcHardY ;
  int4    i=0, j, k, start=0 ;

  if (poly2) kernDist*=kernOvalness;
  while (poly[i]!=END_POLY) {
    if  (poly[i]== NO_CORE) {
      i++; start++; }
    j=i+2;  if (poly[i]==SPLINE) j++;
    if (poly[j]==END_POLY || poly[j]==NEW_LOOP) j=start;

    if (poly[j]==ARC_AUTO) {       //  ** Arc Auto **
      //  Get the two line segments that will be connected by an arc.  Order:  A, B, arc, C, D
      arcAx=poly[i-2]; arcAy=poly[i-1];
      arcBx=poly[i  ]; arcBy=poly[i+1]; j++ ; if (poly[j]==END_POLY || poly[j]==NEW_LOOP) j=start;
      arcCx=poly[j  ]; arcCy=poly[j+1]; j+=2; if (poly[j]==END_POLY || poly[j]==NEW_LOOP) j=start;
      arcDx=poly[j  ]; arcDy=poly[j+1];
      //  Discover the length of line segment AB.
      dX=arcBx-arcAx; dY=arcBy-arcAy; distAB=sqrt(dX*dX+dY*dY);
      //  Translate the line segments so that point B is at the origin.
      rotCx=arcCx-arcBx; rotCy=arcCy-arcBy;
      rotDx=arcDx-arcBx; rotDy=arcDy-arcBy;
      //  Rotate the line segments so that point A is on the positive, X axis.
      theCos=(arcAx-arcBx)/distAB;
      theSin=(arcAy-arcBy)/distAB;
      rotatePointAroundOrigin(&rotCx,&rotCy,theCos,-theSin);
      rotatePointAroundOrigin(&rotDx,&rotDy,theCos,-theSin);
      //  Discover the extenders.
      dcExtend=rotCy/(rotDy-rotCy); sectX=rotCx+(rotCx-rotDx)*dcExtend;
      abExtend=-sectX/distAB;
      //  Discover the two spline corners created by the extenders.
      arcSplineBx=arcBx+(arcBx-arcAx)*abExtend*ARC_FRAC;
      arcSplineBy=arcBy+(arcBy-arcAy)*abExtend*ARC_FRAC;
      arcSplineCx=arcCx+(arcCx-arcDx)*dcExtend*ARC_FRAC;
      arcSplineCy=arcCy+(arcCy-arcDy)*dcExtend*ARC_FRAC;
      //  Discover the new, hard corner inbetween the two spline corners.
      arcHardX=(arcSplineBx+arcSplineCx)*.5;
      arcHardY=(arcSplineBy+arcSplineCy)*.5;
      //  Process the two spline curves that simulate an arc.
      if (poly2) {
        if (!titleKerningDistanceTest(kernDist,kernOvalness,poly2,nil,poly2pos,YES,arcBx,arcBy,arcSplineBx,arcSplineBy,arcHardX,arcHardY)) {
          return NO; }
        if (!titleKerningDistanceTest(kernDist,kernOvalness,poly2,nil,poly2pos,YES,arcHardX,arcHardY,arcSplineCx,arcSplineCy,arcCx,arcCy)) {
          return NO; }}
      else {
        arcBx      +=poly2pos;
        arcSplineBx+=poly2pos;
        arcHardX   +=poly2pos;
        arcSplineCx+=poly2pos;
        arcCx      +=poly2pos;
        if (isSpline) {
          if (distSplineToSpline(
          testSx     *kernOvalness,testSy     ,
          testSplineX*kernOvalness,testSplineY,
          testEx     *kernOvalness,testEy     ,
          arcBx      *kernOvalness,arcBy      ,
          arcSplineBx*kernOvalness,arcSplineBy,
          arcHardX   *kernOvalness,arcHardY   )<kernDist) {
            return NO; }
          if (distSplineToSpline(
          testSx     *kernOvalness,testSy     ,
          testSplineX*kernOvalness,testSplineY,
          testEx     *kernOvalness,testEy     ,
          arcHardX   *kernOvalness,arcHardY   ,
          arcSplineCx*kernOvalness,arcSplineCy,
          arcCx      *kernOvalness,arcCy      )<kernDist) {
            return NO; }}
        else {
          if (distSegToSpline(
          testSx     *kernOvalness,testSy     ,
          testEx     *kernOvalness,testEy     ,
          arcBx      *kernOvalness,arcBy      ,
          arcSplineBx*kernOvalness,arcSplineBy,
          arcHardX   *kernOvalness,arcHardY   )<kernDist) {
            return NO; }
          if (distSegToSpline(
          testSx     *kernOvalness,testSy     ,
          testEx     *kernOvalness,testEy     ,
          arcHardX   *kernOvalness,arcHardY   ,
          arcSplineCx*kernOvalness,arcSplineCy,
          arcCx      *kernOvalness,arcCy      )<kernDist) {
            return NO; }}}}

    else if (poly[i]!=SPLINE && poly[j]!=SPLINE) {   //  ** Line Segment **
      sX=poly[i]; sY=poly[i+1];
      eX=poly[j]; eY=poly[j+1];
      //  Process the line segment.
      if (poly2) {
        if (!titleKerningDistanceTest(kernDist,kernOvalness,poly2,nil,poly2pos,NO,sX,sY,0,0,eX,eY)) {
          return NO; }}
      else {
        sX+=poly2pos;
        eX+=poly2pos;
        if (isSpline) {
          if (distSegToSpline(
          sX         *kernOvalness,sY         ,
          eX         *kernOvalness,eY         ,
          testSx     *kernOvalness,testSy     ,
          testSplineX*kernOvalness,testSplineY,
          testEx     *kernOvalness,testEy     )<kernDist) {
            return NO; }}
        else {
          if (distSegToSeg(
          sX         *kernOvalness,sY         ,
          eX         *kernOvalness,eY         ,
          testSx     *kernOvalness,testSy     ,
          testEx     *kernOvalness,testEy     )<kernDist) {
            return NO; }}}}

    else if (poly[j]==SPLINE) {   //  ** Spline Curve **
      a=poly[j+1]; b=poly[j+2]; k=j+3; if (poly[k]==END_POLY || poly[k]==NEW_LOOP) k=start;
      if  (poly[i]!=SPLINE) {
        sX=poly[i]; sY=poly[i+1]; }
      else {   //  interpolate a hard corner
        sX=(poly[i+1]+poly[j+1])/2.; sY=(poly[i+2]+poly[j+2])/2.; }
      if  (poly[k]!=SPLINE) {
        eX=poly[k]; eY=poly[k+1]; }
      else {   //  interpolate a hard corner
        eX=(poly[j+1]+poly[k+1])/2.; eY=(poly[j+2]+poly[k+2])/2.; }
      //  Process the spline curve.
      if (poly2) {
        if (!titleKerningDistanceTest(kernDist,kernOvalness,poly2,nil,poly2pos,YES,sX,sY,a,b,eX,eY)) {
          return NO; }}
      else {
        sX+=poly2pos;
        a +=poly2pos;
        eX+=poly2pos;
        if (isSpline) {
          if (distSplineToSpline(
          testSx     *kernOvalness,testSy     ,
          testSplineX*kernOvalness,testSplineY,
          testEx     *kernOvalness,testEy     ,
          sX         *kernOvalness,sY         ,
          a          *kernOvalness,b          ,
          eX         *kernOvalness,eY         )<kernDist) {
            return NO; }}
        else {
          if (distSegToSpline(
          testSx     *kernOvalness,testSy     ,
          testEx     *kernOvalness,testEy     ,
          sX         *kernOvalness,sY         ,
          a          *kernOvalness,b          ,
          eX         *kernOvalness,eY         )<kernDist) {
            return NO; }}}}

    //  Advance through the polygon data.  (See the file “Spline Corner Logic”.)
    if       (poly[i]==SPLINE  ) i++;
    i+=2; if (poly[i]==ARC_AUTO) i++;
    if       (poly[i]==NEW_LOOP) {
      i++; start=i; }}

  return YES; }



//  Convenience function used by the function constructTitleGlyphBlackCore.  Finds the next point’s coordinate pair, whether
//  or not it’s a spline point.
//
//  Note:  This function is closely related to nextPoint(), but this copy works correctly in a polygon that uses ARC_AUTO.
//
//  Note:  Assumes that “i” is pointing to a point (possibly a SPLINE tag), but is not pointing to an ARC_AUTO tag.  (Note
//         that this function may return the index of an ARC_AUTO tag, if that is what comes after the point indexed by “i”.)

int4 nextPoint_ArcAuto(double *poly, int4 start, int4 i) {
  //  As luck would have it, nextPoint() works fine for this purpose, so we just call it:
  return nextPoint(poly,start,i); }



//  Convenience function used by the function constructTitleGlyphBlackCore.  Finds the previous point’s coordinate pair,
//  whether or not it’s a spline point.
//
//  See the file “Polygon Constants” for a detailed description of how the polygon tags work.
//
//  Note:  This function is closely related to prevPoint(), but this copy works correctly in a polygon that uses ARC_AUTO.
//
//  Note:  Assumes that “i” is pointing to a point (possibly a SPLINE point), but is not pointing to a SPLINE tag or to an
//         ARC_AUTO tag.  (Note that this function may return the index of an ARC_AUTO tag, if that is what comes before
//         the point indexed by “i”.)

int4 prevPoint_ArcAuto(double *poly, int4 start, int4 i) {
  if (i==start || i-1==start) while (poly[i]!=END_POLY && poly[i]!=NEW_LOOP) i++;
  if (poly[i-1]==SPLINE  ) return i-3;
  if (poly[i-1]==ARC_AUTO) return i-1;
  return                          i-2; }



//  Copies polygon glyph data from src to dst, while shrinking the glyph inward by a fixed distance
//  all around, using a technique very similar to the bevelling effect used in the Distributor logo.
//
//  See the file “Polygon Constants” for a detailed description of how the polygon tags work.
//
//  Important:  dst must contain enough room for at least as much data as that required by the glyph
//              in src.
//
//  Note:  The data size of the glyph will not change; only its polygon-corner-coordinate values will.
//
//  Note:  This function recognizes only these polygon-data tags: END_POLY, NEW_LOOP, SPLINE, NO_CORE,
//         and ARC_AUTO.

void constructTitleGlyphBlackCore(double *src, double *dst) {

  int4  i=0, prevI, nextI, start=0 ;

  while (src[i]!=END_POLY) {
    if  (src[i]==NEW_LOOP || src[i]==NO_CORE) start=i+1;
    if  (src[i]==NEW_LOOP || src[i]==NO_CORE || src[i]==SPLINE || src[i]==ARC_AUTO) dst[i]=src[i];
    else {
      prevI=prevPoint_ArcAuto(src,start,i); dst[i  ]=src[i  ];
      nextI=nextPoint_ArcAuto(src,start,i); dst[i+1]=src[i+1];
      findBevelInsetPoint(src[prevI],src[prevI+1],&dst[i],&dst[i+1],src[nextI],src[nextI+1],TITLE_CORE_INSET);
      i++; }
    i++; }
  dst[i]=src[i]; }



//  Extract data about the Title font into an array.  (The availability of this data in this array
//  helps rendering speed.)
//
//  Called only once, on app launch.
//
//  Returns an error string, or nil (not an empty string) if there is no error.
//
//  See the file “Polygon Constants” for a detailed description of how the polygon tags work.

BYTE *processTitleFont() {

  BYTE  *titleFontCorrupt="The Title font appears to be corrupt." ;

  int4    i, j, start, chr ;
  double  trMax, brMax     ;

  //  Determine the range of glyphs covered by the Title font, and fix non-Unicode character values.
  i=0; TitleGlyphs=0;
  while       (TitleFont[i]!=END_POLY) {
    chr=(int4) TitleFont[i]; if (chr<=-UTF8_CHARS || chr>=UTF8_CHARS) return "Invalid character found by processorTitleFont.";
    convertMacCharToUnicode(&chr); TitleFont[i++]=(double) chr; if (chr>=TitleGlyphs) TitleGlyphs=chr+1;
    if           (i>=TitleFont_elementCount) return titleFontCorrupt;
    while     (TitleFont[i]!=END_POLY) {
      if      (TitleFont[i]==NEW_LOOP) {
        i++ ; if (i>=TitleFont_elementCount) return titleFontCorrupt; }
      if      (TitleFont[i]==NO_CORE ) {
        i++ ; if (i>=TitleFont_elementCount) return titleFontCorrupt; }
      if      (TitleFont[i]==SPLINE  ) {
        i++ ; if (i>=TitleFont_elementCount) return titleFontCorrupt; }
      if      (TitleFont[i]==ARC_AUTO) {
        i++ ; if (i>=TitleFont_elementCount) return titleFontCorrupt; }
      else {
        i+=2; if (i>=TitleFont_elementCount) return titleFontCorrupt; }}
    i++;      if (i>=TitleFont_elementCount) return titleFontCorrupt; }
  if (TitleGlyphs>MAX_INT4/sizeof(TitleGlyph_)) return "Range-of-int4 overrun found by processorTitleFont.";
  if (TitleGlyphs<1                           ) return "No glyphs found in Title font.";

  //  Allocate an array of distributor glyph data.
  if ( TitleGlyph) return "Duplicate allocation of TitleGlyph found by processorTitleFont.";
  TitleGlyph=(TitleGlyph_ *) malloc(TitleGlyphs*sizeof(TitleGlyph_));
  if (!TitleGlyph) return "Memory allocation failure in processorTitleFont.";

  //  Initialize array with default values.
  for (i=0L; i<TitleGlyphs; i++) {
    TitleGlyph[i].width    = 0.;
    TitleGlyph[i].top      =TITLE_GLYPH_RANGE;
    TitleGlyph[i].bot      = 0.;
    TitleGlyph[i].start    = 1 ;
    TitleGlyph[i].ribbonTLi=-1 ;
    TitleGlyph[i].ribbonTRi=-1 ;
    TitleGlyph[i].ribbonBLi=-1 ;
    TitleGlyph[i].ribbonBRi=-1 ; }

  //  Extract information about the glyphs that are supported by the font.  (This plays
  //  a little fast-and-loose, since some things have already been verified above.)
  i=0L;
  while       (TitleFont[i  ]!=END_POLY) {
    chr=(int4) TitleFont[i++]; trMax=0.; brMax=0.; start=i; TitleGlyph[chr].start=i;
    while     (TitleFont[i  ]!=END_POLY) {
      j=i+2; if (TitleFont[j]==END_POLY || TitleFont[j]==NEW_LOOP) j=start;
      if      (TitleFont[i  ]== 0.
      &&       TitleFont[j  ]== 0.) {
        if    (TitleFont[i+1]== 0.
        &&     TitleFont[j+1]==                  TITLE_GLYPH_CONNECTOR_HEI) {
          TitleGlyph[chr].ribbonBLi=i-TitleGlyph[chr].start; }
        if    (TitleFont[i+1]==TITLE_GLYPH_RANGE-TITLE_GLYPH_CONNECTOR_HEI
        &&     TitleFont[j+1]==TITLE_GLYPH_RANGE) {
          TitleGlyph[chr].ribbonTLi=i-TitleGlyph[chr].start; }}
      if     ((TitleFont[i  ]< POLY_TAG_MIN
      ||       TitleFont[i  ]> POLY_TAG_MAX)
      &&       TitleFont[i  ]==TitleFont[i+2]) {
        if    (TitleFont[i+1]==TITLE_GLYPH_RANGE
        &&     TitleFont[j+1]==TITLE_GLYPH_RANGE-TITLE_GLYPH_CONNECTOR_HEI
        &&     TitleFont[i  ]> trMax) {
          trMax=TitleFont[i]; TitleGlyph[chr].ribbonTRi=i-TitleGlyph[chr].start; }
        if    (TitleFont[i+1]==    TITLE_GLYPH_CONNECTOR_HEI
        &&     TitleFont[j+1]== 0.
        &&     TitleFont[i  ]> brMax) {
          brMax=TitleFont[i]; TitleGlyph[chr].ribbonBRi=i-TitleGlyph[chr].start; }}
      if      (TitleFont[i]==NEW_LOOP) {
        i++; start=i; }
      if      (TitleFont[i]==NO_CORE ) i++;
      if      (TitleFont[i]==SPLINE  ) i++;
      if      (TitleFont[i]==ARC_AUTO) i++;
      else {
        if (TitleFont[i  ]>TitleGlyph[chr].width) TitleGlyph[chr].width=TitleFont[i  ];
        if (TitleFont[i+1]>TitleGlyph[chr].top  ) TitleGlyph[chr].top  =TitleFont[i+1];
        if (TitleFont[i+1]<TitleGlyph[chr].bot  ) TitleGlyph[chr].bot  =TitleFont[i+1]; i+=2L; }}
    i++;
    if (i-TitleGlyph[chr].start>TITLE_GLYPH_MAX_BYTES) {
      return "One of the Title font’s glyphs is too large; try increasing the size limit."; }}

  //  Give all unsupported glyphs the width of a big square (-1. to 1.).
  for (i=0L; i<TitleGlyphs; i++) if (TitleGlyph[i].width==0.) TitleGlyph[i].width=TITLE_GLYPH_RANGE;

  //  Success -- return no error message.
  return nil; }



//  Prepares a null-terminated string for use as a Title logo.

void prepTitleText(int4 *text) {
  straightQuotesToDirectional(text);
  stripExtraSpaces           (text);
  forceAtLeastOneChar        (text);
  forceUpperCase             (text); }



//  Finds the highest glyph top and lowest glyph bottom in a specified range of Title text characters.
//
//  Used by the function prepareToDrawTitleImage when it is determining where each character will be
//  positioned within the Title logo.

void findTitleRowTopBot(int4 start, int4 end, double *bot, double *top) {

  double  b, t ;
  int4    i    ;

  *bot=0.; *top=TITLE_GLYPH_RANGE;

  for (i=start; i<end; i++) {
    b=TitleGlyph[TitleText[i]].bot; if (b<(*bot)) *bot=b;
    t=TitleGlyph[TitleText[i]].top; if (t>(*top)) *top=t; }}



//  Returns the distance (in glyph coordinates) that the indicated Title character should be positioned
//  horizontally, with respect to the preceding character.
//
//  Pass in the index of the Title character that needs to be kerned with respect to the *preceding* character.
//
//  Warning:  Do not pass in zero, or the index of any character that is at the start of its text row in
//            the logo -- such characters do not need to be kerned, and could crash this function.
//
//     Note:  Assumes that the left side of each glyph lines up with the Y axis (i.e. X==0).  (If that glyph
//            requirement is ever dropped, then the starting value of charBpos must be calculated differently.
//            The starting value should be the largest possible x-position of charB with respect to charA.)
//
//     Note:  This technique seems to work fine for the Title font, but theoretically might be confused by more
//            complex glyphs (i.e. with thinner strokes), resulting in sub-optimal character positioning.

double titleKern(int4 i) {

  int4    charA=TitleText[i-1] ;
  int4    charB=TitleText[i  ] ;
  double  step=TITLE_CHAR_SEP*(1.-.5/TITLE_KERN_OVAL_RATIO)+.5*minDouble(TitleGlyph[charA].width,TitleGlyph[charB].width) ;
  double  charBpos=TitleGlyph[charA].width+TITLE_CHAR_SEP, kernDist, kernOvalness ;

  //  Don’t try to kern if either character is a space.
  if (charA==' ' || charB==' ') return charBpos;

  //  Set kerning distance and ovalness, which may involve special exceptions for certain characters.
  kernDist    =TITLE_CHAR_SEP       ;
  kernOvalness=TITLE_KERN_OVAL_RATIO; if (charA=='T' || charB=='T') kernOvalness=1.;

  //  Loop to iteratively hone-in on the best kerning position for character B.
  while (step>TITLE_GLYPH_RANGE/500.) {

    //  Cut movement distance by half.
    step*=.5;

    //  Tenatively move character B to the left.
    charBpos-=step;

    //  Undo character B’s tentative leftward movement if it places the characters too close together.
    if (!titleKerningDistanceTest(kernDist,kernOvalness,
    &TitleFont[TitleGlyph[charA].start],
    &TitleFont[TitleGlyph[charB].start],charBpos,NO,0.,0.,0.,0.,0.,0.)) {
      charBpos+=step; }}

  //  Special exceptions for certain character(s).
  if (TitleGlyph[charA].ribbonTRi>=0 && charB=='T'
  ||  TitleGlyph[charB].ribbonTLi>=0 && charA=='T') {
    charBpos-=TITLE_CHAR_T_ADJUSTMENT; }

  //  Return best kerning position found for character B.
  return charBpos; }



//  Perform the necessary preparations for rendering the Title image.

void prepareToDrawTitleImage(BYTE **rgb, int4 rowBytes) {

  int4    i, j, rows, row, rowStart[TITLE_ROW_COUNT_MAX], rowEnd[TITLE_ROW_COUNT_MAX], mid, splitI ;
  double  rowWid[TITLE_ROW_COUNT_MAX], titleWid, titleHei, ratioByHei, oldTitleWid, oldTitleHei    ;
  double  rowTop[TITLE_ROW_COUNT_MAX], charX, charY ;
  double  rowBot[TITLE_ROW_COUNT_MAX] ;
  bool    done ;

  straightQuotesToDirectional(&TitleText[0]);

  //  Store the passed parameters in globals, for use during image drawing.
  PreviewRgb     =rgb     ;
  PreviewRowBytes=rowBytes;

  //  Constrain all character values to the range of the Title font.
  i=-1; while (TitleText[++i]) if (TitleText[i]>=TitleGlyphs) TitleText[i]=1;

  //  Divide the Title text into a set of rows that will yield a logo approximately the ratio of the movie screen.
  rowWid[0]=0.; i=1; while (TitleText[i]) rowWid[0]+=titleKern(i++);
  rowWid[0]+=TitleGlyph[TitleText[i-1]].width;
  if (TitleGlyph[TitleText[  0]].ribbonBLi>=0) rowWid[0]+=TITLE_RIBBON_L_MINIMUM;
  if (TitleGlyph[TitleText[i-1]].ribbonBRi>=0) rowWid[0]+=TITLE_RIBBON_R_MINIMUM;
  rows=1; done=NO; rowStart[0]=0; rowEnd[0]=i;   titleWid=rowWid[0]          ;
  findTitleRowTopBot(0,i,&rowBot[0],&rowTop[0]); titleHei=rowTop[0]-rowBot[0];
  while (!done) {
    //  Try to split lengthiest row into two, shorter rows.
    for (i=0; i<rows; i++) if (rowWid[i]==titleWid) break;
    if (i==rows) done=YES;
    else {
      j=0; mid=(rowStart[i]+rowEnd[i])/2; splitI=-1;
      while     ((mid-j>rowStart[i]
      ||          mid+j<rowEnd  [i]-1) && splitI<0) {
        if      ( mid-j>rowStart[i]    && TitleText[mid-j]==' ') splitI=mid-j;
        else if ( mid+j<rowEnd  [i]-1  && TitleText[mid+j]==' ') splitI=mid+j;
        j++; }
      if (splitI<0) done=YES;
      else {   //  splitting at character splitI (which is in row i)
        oldTitleWid=titleWid;
        oldTitleHei=titleHei;
        for (j=rows; j>i; j--) {
          rowStart[j]=rowStart[j-1];
          rowEnd  [j]=rowEnd  [j-1];
          rowWid  [j]=rowWid  [j-1]; }
        rowEnd  [i  ]=splitI  ;
        rowStart[i+1]=splitI+1; rows++;
        rowWid  [i  ]=0.; j=rowStart[i  ]+1; while (j<rowEnd[i  ]) rowWid[i  ]+=titleKern(j++); rowWid[i  ]+=TitleGlyph[TitleText[j-1]].width;
        rowWid  [i+1]=0.; j=rowStart[i+1]+1; while (j<rowEnd[i+1]) rowWid[i+1]+=titleKern(j++); rowWid[i+1]+=TitleGlyph[TitleText[j-1]].width;
        if (!i) {
          if (TitleGlyph[TitleText[rowStart[i  ]  ]].ribbonBLi>=0) rowWid[i  ]+=TITLE_RIBBON_L_MINIMUM;
          if (TitleGlyph[TitleText[rowEnd  [i  ]-1]].ribbonBRi>=0) rowWid[i  ]+=TITLE_RIBBON_R_MINIMUM; }
        if (i+1==rows-1) {
          if (TitleGlyph[TitleText[rowStart[i+1]  ]].ribbonTLi>=0) rowWid[i+1]+=TITLE_RIBBON_L_MINIMUM;
          if (TitleGlyph[TitleText[rowEnd  [i+1]-1]].ribbonTRi>=0) rowWid[i+1]+=TITLE_RIBBON_R_MINIMUM; }
        titleWid=0.; titleHei=-TITLE_ROW_SEP;
        for (j=0; j<rows; j++) {
          findTitleRowTopBot(rowStart[j],rowEnd[j],&rowBot[j],&rowTop[j]); if (rowWid[j]>titleWid) titleWid=rowWid[j];
          titleHei+=TITLE_ROW_SEP+rowTop[j]-rowBot[j]; }
        //  If the ratio has sunk below the movie-screen ratio, the splitting loop must now end.
        if (titleWid/titleHei<MOVIE_SCREEN_WID/MOVIE_SCREEN_HEI) {
          done=YES;
          //  If the ratio was better before the split, undo the split before dropping out of the loop.
          if ((MOVIE_SCREEN_WID/MOVIE_SCREEN_HEI)/(titleWid/titleHei)>(oldTitleWid/oldTitleHei)/(MOVIE_SCREEN_WID/MOVIE_SCREEN_HEI)) {
            rows--; rowEnd[i]=rowEnd[i+1];
            for (j=i+1; j<rows; j++) {
              rowStart[j]=rowStart[j+1];
              rowEnd  [j]=rowEnd  [j+1];
              rowWid  [j]=rowWid  [j+1]; }
            rowWid[i]=0.; j=rowStart[i]+1; while (j<rowEnd[i]) rowWid[i]+=titleKern(j++); rowWid[i]+=TitleGlyph[TitleText[j-1]].width;
            if (!i) {
              if (TitleGlyph[TitleText[rowStart[i]  ]].ribbonBLi>=0) rowWid[i]+=TITLE_RIBBON_L_MINIMUM;
              if (TitleGlyph[TitleText[rowEnd  [i]-1]].ribbonBRi>=0) rowWid[i]+=TITLE_RIBBON_R_MINIMUM; }
            else if (i==rows-1) {
              if (TitleGlyph[TitleText[rowStart[i]  ]].ribbonTLi>=0) rowWid[i]+=TITLE_RIBBON_L_MINIMUM;
              if (TitleGlyph[TitleText[rowEnd  [i]-1]].ribbonTRi>=0) rowWid[i]+=TITLE_RIBBON_R_MINIMUM; }
            titleWid=0.; titleHei=-TITLE_ROW_SEP;
            for (j=0; j<rows; j++) {
              findTitleRowTopBot(rowStart[j],rowEnd[j],&rowBot[j],&rowTop[j]); if (rowWid[j]>titleWid) titleWid=rowWid[j];
              titleHei+=TITLE_ROW_SEP+rowTop[j]-rowBot[j]; }}}
        //  If the row limit is reached, end the row-splitting loop.
        if (rows==TITLE_ROW_COUNT_MAX) done=YES; }}}

  //  Parse the individual Title characters into movie-screen positions.
  TitleGlyphToMovieScreenRatio=MOVIE_SCREEN_WID/titleWid; TitleChars=0;
  ratioByHei                  =MOVIE_SCREEN_HEI/titleHei;
  if (ratioByHei<TitleGlyphToMovieScreenRatio) TitleGlyphToMovieScreenRatio=ratioByHei;
  charY=titleHei*.5*TitleGlyphToMovieScreenRatio; TitleMovieScreenWidth=titleWid*TitleGlyphToMovieScreenRatio;
  for (row=0; row<rows; row++) {
    charX=-rowWid[row]*.5*TitleGlyphToMovieScreenRatio;
    //  Reposition the row for minimum-length leading ribbon.
    if (!row                && TitleGlyph[TitleText[rowStart[row]]].ribbonBLi>=0) charX+=TITLE_RIBBON_L_MINIMUM*TitleGlyphToMovieScreenRatio;
    if ( row && row==rows-1 && TitleGlyph[TitleText[rowStart[row]]].ribbonTLi>=0) charX+=TITLE_RIBBON_L_MINIMUM*TitleGlyphToMovieScreenRatio;
    //  Reposition the row to extend the leading/trailing ribbons to the full width of the logo.
    if (!row) {
      if (TitleGlyph[TitleText[rowStart[row]  ]].ribbonBLi< 0
      &&  TitleGlyph[TitleText[rowEnd  [row]-1]].ribbonBRi>=0) {
        charX=-titleWid*.5*TitleGlyphToMovieScreenRatio; }
      if (TitleGlyph[TitleText[rowStart[row]  ]].ribbonBLi>=0
      &&  TitleGlyph[TitleText[rowEnd  [row]-1]].ribbonBRi< 0) {
        charX=(titleWid*.5-rowWid[row]+TITLE_RIBBON_L_MINIMUM)*TitleGlyphToMovieScreenRatio; }}
    if (row && row==rows-1) {
      if (TitleGlyph[TitleText[rowStart[row]  ]].ribbonTLi< 0
      &&  TitleGlyph[TitleText[rowEnd  [row]-1]].ribbonTRi>=0) {
        charX=-titleWid*.5*TitleGlyphToMovieScreenRatio; }
      if (TitleGlyph[TitleText[rowStart[row]  ]].ribbonTLi>=0
      &&  TitleGlyph[TitleText[rowEnd  [row]-1]].ribbonTRi< 0) {
        charX=(titleWid*.5-rowWid[row]+TITLE_RIBBON_L_MINIMUM)*TitleGlyphToMovieScreenRatio; }}
    //  Position the individual characters.
    for (i=rowStart[row]; i<rowEnd[row]; i++) {
      if         (TitleChars<MAX_CHARS_TITLE) {
        TitleChar[TitleChars].uni   =TitleText[i];
        TitleChar[TitleChars].rowL  =(i==rowStart[row]  );
        TitleChar[TitleChars].rowR  =(i==rowEnd  [row]-1);
        TitleChar[TitleChars].rowT  =(row==     0);
        TitleChar[TitleChars].rowB  =(row==rows-1);
        TitleChar[TitleChars].rect.L=charX;
        TitleChar[TitleChars].rect.B=charY- rowTop[row]                   *TitleGlyphToMovieScreenRatio;
        TitleChar[TitleChars].Bextra=
        TitleChar[TitleChars].rect.B;
        TitleChar[TitleChars].rect.T=charY-(rowTop[row]-TITLE_GLYPH_RANGE)*TitleGlyphToMovieScreenRatio;
        TitleChar[TitleChars].Textra=
        TitleChar[TitleChars].rect.T;
        TitleChar[TitleChars].rect.R=charX+TitleGlyph[TitleText[i]].width*TitleGlyphToMovieScreenRatio;
        if (i+1<rowEnd[row]) charX+=titleKern(i+1)*TitleGlyphToMovieScreenRatio;
        if (TitleGlyph[TitleText[i]].top>TITLE_GLYPH_RANGE
        ||  TitleGlyph[TitleText[i]].bot<               0.) {
          TitleChar[TitleChars].Bextra+= TitleGlyph[TitleText[i]].bot                   /TITLE_GLYPH_RANGE*(TitleChar[TitleChars].rect.T-TitleChar[TitleChars].rect.B);
          TitleChar[TitleChars].Textra+=(TitleGlyph[TitleText[i]].top-TITLE_GLYPH_RANGE)/TITLE_GLYPH_RANGE*(TitleChar[TitleChars].rect.T-TitleChar[TitleChars].rect.B); }
        TitleChars++; }}
    charY-=(rowTop[row]-rowBot[row]+TITLE_ROW_SEP)*TitleGlyphToMovieScreenRatio; }}



//  Closely related to handleSplineCurveForNodesRow, but simplified for use with Title only.

void handleSplineCurveForNodesRow_Title(
double y, double sX, double sY, double a, double b, double eX, double eY, int4 subPixelRow, int4 polyCount,
int4 *nodes, double *nodeX, int4 *polyTag) {

  double  bottomPart, topPart, xPart, sRoot, f ;
  int4    base ;

  //  Do the spline-curve math.
  bottomPart=2.*(sY+eY-b-b);
  if (bottomPart==0.) {   //  prevent division-by-zero
    b+=.0001; bottomPart-=.0004; }
  sRoot=2.*(b-sY); sRoot*=sRoot; sRoot-=2.*bottomPart*(sY-y);
  if (sRoot>=0.) {
    sRoot=sqrt(sRoot); topPart=2.*(sY-b);
    f=(topPart+sRoot)/bottomPart;
    if (f>=0. && f<=1.) {
      xPart=sX+f*(a-sX);
      if (nodes[subPixelRow]<NODE_ROW_MAX) {
        base=subPixelRow*NODE_ROW_MAX;
        nodeX  [base+nodes[subPixelRow]]=xPart+f*(a+f*(eX-a)-xPart);
        polyTag[base+nodes[subPixelRow]]=polyCount; nodes[subPixelRow]++; }}
    f=(topPart-sRoot)/bottomPart;
    if (f>=0. && f<=1.) {
      xPart=sX+f*(a-sX);
      if (nodes[subPixelRow]<NODE_ROW_MAX) {
        base=subPixelRow*NODE_ROW_MAX;
        nodeX  [base+nodes[subPixelRow]]=xPart+f*(a+f*(eX-a)-xPart);
        polyTag[base+nodes[subPixelRow]]=polyCount; nodes[subPixelRow]++; }}}}



//  Given the sequentially connected points (a,b), (c,d), and (e,f), this function returns a bevel-inset replacement
//  for point (c,d).  (See the file “Distributor Character Bevelling.cwk” for more info about this insetting technique.)
//
//  Note 1:  If vectors (a,b)->(c,d) and (c,d)->(e,f) are exactly 180° opposed, or if either segment is zero-length, this
//           function will do nothing; i.e. point (c,d) will not be changed.
//
//  Note 2:  If input variable “a” or “e” contains the constant ARC_AUTO, this function knows what to do to ensure that point
//           (c,d) is inset correctly.  However, if both “a” and “e” contain ARC_AUTO, the polygon is defective, and no
//           insetting will occur; i.e. point (c,d) will not be changed.

void findBevelInsetPoint(
double  a, double  b,   //  previous point
double *c, double *d,   //  current point that needs to be inset
double  e, double  f,   //  next point
double insetDist) {     //  amount of perpendicular inset (perpendicular to each line segment)

  double  c1=*c, d1=*d, c2=*c, d2=*d, dx1, dy1, dist1, dx2, dy2, dist2, insetX, insetY ;

  //  Handle ARC_AUTO as needed.  (See Note 2 above.)
  if   (a==ARC_AUTO) {
    if (e==ARC_AUTO) return;
    a=(*c)+(*c)-e;
    b=(*d)+(*d)-f; }
  if   (e==ARC_AUTO) {
    e=(*c)+(*c)-a;
    f=(*d)+(*d)-b; }

  //  Calculate length of line segments.
  dx1=  (*c)-a;
  dy1=  (*d)-b; dist1=sqrt(dx1*dx1+dy1*dy1);
  dx2=e-(*c)  ;
  dy2=f-(*d)  ; dist2=sqrt(dx2*dx2+dy2*dy2);

  //  Ensure no zero-length segments.
  if (dist1==0. || dist2==0.) return;

  //  Inset each of the two line segments.
  insetX= dy1/dist1*insetDist; a+=insetX; c1+=insetX;
  insetY=-dx1/dist1*insetDist; b+=insetY; d1+=insetY;
  insetX= dy2/dist2*insetDist; e+=insetX; c2+=insetX;
  insetY=-dx2/dist2*insetDist; f+=insetY; d2+=insetY;

  //  If inset segments connect perfectly, return the connection point.
  if (c1==c2 && d1==d2) {
    *c=c1; *d=d1; return; }

  //  Return the intersection point of the two inset segments (if any).
  if (linesIntersect(a,b,c1,d1,c2,d2,e,f,&insetX,&insetY)) {
    *c=insetX; *d=insetY; }}



//=====STARFIELD FUNCTIONS START HERE



//  Determines if a star is relevant to a given row of image pixels.  Used when building the SubStar array.
//
//  Closely related to starLev() -- if you change it, you may need to change this, too.
//
//  Y should be in movie-screen coordinates -- see the file “Coordinate Systems”.

bool starRelevant(int4 starI, double y, double yUp) {

  double  dY=y-Star[starI].y ;

  if            (dY<0.) dY*=-1.;
  dY-=yUp-y; if (dY<0.) dY = 0.;

  return (dY*dY)/Star[starI].size2<STAR_CUTOFF*STAR_CUTOFF; }



//  Returns a value from 0 to 1, representing the brightness of the starfield at the specified point.
//
//  Note:  The standard formula for a bell curve is:   y  =  e ^ (-(x^2)/2)
//
//  Note:  If you change this function, you may need to change starRelevant(), too.

double starLev(double x, double y, int4 pixelY) {

  double  lev=0., dX, dY, dist2 ;
  int4    i ;

  for (i=SubStar[pixelY].start; i<SubStar[pixelY].end; i++) {
    dX=x-Star[i].x;
    dY=y-Star[i].y; dist2=(dX*dX+dY*dY)/Star[i].size2;
    if (dist2<STAR_CUTOFF*STAR_CUTOFF) lev+=pow(MATH_E,-dist2*.5); }
  lev*=STAR_BRIGHTNESS_MODERATOR;

  //  Prevent overload.
  if (lev>1.) lev=1.;

  return lev; }



//  Generates a random set of stars for the starfield that lies behind the text crawl.
//
//  This function is called only once (during app startup), so the starfield does not
//  change unless the user closes and relaunches the app.

void generateStarField() {

  double  swapDouble ;
  int4    i ;

  //  Seed the random number generator.
  srandomdev();

  //  Generate the starfield.
  for (i=0; i<STARS; i++) {
    Star[i].x    =(rnd0to1()*MOVIE_SCREEN_WID-MOVIE_SCREEN_WID*.5)*STAR_OVERREACH ;
    Star[i].y    =(rnd0to1()*MOVIE_SCREEN_HEI-MOVIE_SCREEN_HEI*.5)*STAR_OVERREACH ;
    Star[i].size2=            STAR_SIZE_MIN
    +rnd0to1()*(STAR_SIZE_MAX-STAR_SIZE_MIN)/3.
    +rnd0to1()*(STAR_SIZE_MAX-STAR_SIZE_MIN)/3.
    +rnd0to1()*(STAR_SIZE_MAX-STAR_SIZE_MIN)/3.;
    Star[i].size2*=Star[i].size2; }

  //  Sort the stars by their Y coordinates (irrespective of size).  This is necessary so that the construction of the
  //  SubStar array will be useful.
  i=0;
  while (i<STARS-1) {
    if (Star[i].y>Star[i+1].y) {
      swapDouble=Star[i].y; Star[i].y=Star[i+1].y; Star[i+1].y=swapDouble; if (i) i--; }
    else {
      i++; }}

  //  Create the SubStar ranges that make rendering the starfield much more efficient.
  createSubStarRanges(); }



//  Create a range of relevant stars for each row of pixels, which greatly speeds up the rendering of the starfield.
//
//  * This function is called by generateStarField(), and again whenever the image size is changed.
//  * This technique depends on the stars already having been vertically sorted -- that is done by generateStarField().
//  * This technique does not guarantee that only relevant stars (as defined by starRelevant) will be included in each
//    range -- some smaller stars may be included anyway.  That’s OK; all we’re trying to do here is substantially
//    improve rendering efficiency by eliminating most of the stars in advance.

void createSubStarRanges() {

  int4  row, star ;

  for (row=0; row<ImageHei; row++) {
    SubStar[row].start=STARS;
    SubStar[row].end  =    0;
    for (star=0; star<STARS; star++) {
      if (starRelevant(star,
      pixelToScreenY((double) row+.5),
      pixelToScreenY((double) row-.5))) {
        SubStar[row].end=star+1; if (SubStar[row].start==STARS) SubStar[row].start=star; }}}}



//  Forces the Title preview area to be re-rendered.
//
//  Note:  TitleDist should be set to the preview distance before calling this function.
//
//  Note:  The controller never calls this function with render threads running.

void forceRasterTitlePreview(bool lo, bool hi) {
  forceRasterRect(lo,hi,
  (int4) screenToPixelX(-MOVIE_SCREEN_WID*.5/TitleDist)-2,
  (int4) screenToPixelY( MOVIE_SCREEN_HEI*.5/TitleDist)-2,
  (int4) screenToPixelX( MOVIE_SCREEN_WID*.5/TitleDist)+3,
  (int4) screenToPixelY(-MOVIE_SCREEN_HEI*.5/TitleDist)+3); }